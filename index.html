<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>10 ç§’éŒ„éŸ³ï¼‹å³æ™‚æ³¢å½¢èˆ‡ä¸»é »åˆ†æï¼ˆä½é€šæ¿¾æ³¢ç‰ˆï¼‰</title>
<style>
  :root { --gap: 10px; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto; padding: 16px; }
  h2 { margin: 0 0 12px 0; }
  .toolbar { display: flex; flex-wrap: wrap; gap: var(--gap); margin-bottom: 12px; align-items: center; }
  button { padding: 10px 14px; border: 1px solid #ccc; border-radius: 10px; cursor: pointer; background: #fafafa; }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .controls { display: flex; flex-wrap: wrap; gap: 14px; align-items: center; }
  .control { display: flex; align-items: center; gap: 8px; }
  #status { margin-left: 6px; font-size: 14px; color: #555; }
  .canvases { display: grid; gap: var(--gap); }
  canvas { width: 100%; height: 200px; border: 1px solid #ddd; border-radius: 8px; background: #fff; }
  .panel { display: grid; gap: 6px; }
  .freqs { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; padding: 10px; border: 1px solid #eee; border-radius: 8px; background: #fcfcfc; }
  .note { font-size: 12px; color:#666; margin-top: 8px; }
  label { user-select: none; }
</style>
</head>
<body>
  <h2>è²éŸ³éŒ„è£½èˆ‡ä¸»é »åˆ†æ</h2>

  <div class="toolbar">
    <button id="btnStart">ğŸ¤ éŒ„éŸ³ 10 ç§’</button>
    <button id="btnPause" disabled>â¸ æš«åœæ³¢å½¢</button>
    <button id="btnClear">ğŸ§¹ æ¸…é™¤</button>
    <span id="status"></span>
  </div>

  <div class="controls">
    <div class="control">
      <label for="gain">æŒ¯å¹…æ”¾å¤§ï¼š</label>
      <input id="gain" type="range" min="1" max="6" step="0.5" value="2">
      <span id="gainVal">2.0Ã—</span>
    </div>
    <div class="control" title="æˆªæ­¢é »è¶Šä½ï¼Œè¶Šèƒ½å£“æ‰é«˜é »é›œè¨Šï¼ˆå»ºè­° 1000â€“3000 Hzï¼‰">
      <label for="lpCut">ä½é€šæˆªæ­¢é »ï¼š</label>
      <input id="lpCut" type="range" min="300" max="8000" step="100" value="2000">
      <span id="lpVal">2000 Hz</span>
    </div>
  </div>

  <div class="canvases" style="margin-top:10px;">
    <div class="panel">
      <label>å³æ™‚æ³¢å½¢ï¼ˆTime Domainï¼‰</label>
      <canvas id="waveCanvas" width="900" height="220"></canvas>
    </div>
  </div>

  <div class="panel">
    <label>å‰ä¸‰å¤§ä¸»é »ï¼ˆå³æ™‚ï¼Œå·²å¥—ç”¨ä½é€šï¼‰</label>
    <div id="freqReadout" class="freqs">å°šæœªé–‹å§‹</div>
  </div>
  <div class="note">æç¤ºï¼šè«‹åœ¨ HTTPS çš„é ‚å±¤é é¢é–‹å•Ÿï¼ˆGoogle Sites è«‹ç”¨ã€ŒæŒ‰éˆ•â†’æ–°è¦–çª—é–‹å•Ÿã€ï¼‰ã€‚é¦–æ¬¡ä½¿ç”¨æœƒè·³å‡ºéº¥å…‹é¢¨æˆæ¬Šã€‚</div>

<script>
(()=> {
  // --- UI åƒè€ƒ ---
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnClear = document.getElementById('btnClear');
  const statusEl = document.getElementById('status');
  const waveCanvas = document.getElementById('waveCanvas');
  const wctx = waveCanvas.getContext('2d');
  const freqReadout = document.getElementById('freqReadout');
  const gainSlider = document.getElementById('gain');
  const gainVal = document.getElementById('gainVal');
  const lpCut = document.getElementById('lpCut');
  const lpVal = document.getElementById('lpVal');

  // --- ç‹€æ…‹ ---
  let audioCtx = null;
  let analyser = null;
  let mediaStream = null;
  let mediaSource = null;
  let lowpass = null;        // ä½é€šæ¿¾æ³¢å™¨
  let rafId = null;
  let drawFrozen = false;
  let drawingStarted = false;
  let freqTimer = null;
  let mediaRecorder = null;
  let recordTimer = null;
  let ampGain = parseFloat(gainSlider.value);

  // FFT/åˆ†æè¨­å®š
  const FFT_SIZE = 4096;
  const FREQ_UPDATE_MS = 150;
  const DRAW_BG = '#ffffff';

  function setStatus(msg) { statusEl.textContent = msg || ''; }

  function resetAll() {
    if (rafId) cancelAnimationFrame(rafId); rafId = null;
    if (freqTimer) clearInterval(freqTimer); freqTimer = null;
    if (recordTimer) clearTimeout(recordTimer); recordTimer = null;

    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      try { mediaRecorder.stop(); } catch {}
    }
    mediaRecorder = null;

    if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
    if (audioCtx) { try { audioCtx.close(); } catch {} audioCtx = null; }

    analyser = null;
    mediaSource = null;
    lowpass = null;
    drawingStarted = false;
    drawFrozen = false;

    btnPause.textContent = 'â¸ æš«åœæ³¢å½¢';
    btnPause.disabled = true;
    setStatus('');
  }

  function clearScreen() {
    wctx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
    freqReadout.textContent = '';
  }

  function drawWaveform() {
    if (!analyser) return;

    const buffer = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(buffer);

    // èƒŒæ™¯èˆ‡ä¸­å¿ƒç·š
    wctx.fillStyle = DRAW_BG;
    wctx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
    wctx.strokeStyle = '#e6e6e6';
    wctx.lineWidth = 1;
    wctx.beginPath();
    wctx.moveTo(0, waveCanvas.height/2);
    wctx.lineTo(waveCanvas.width, waveCanvas.height/2);
    wctx.stroke();

    // ç•«æ•´æ®µï¼ˆä¸å†é™åˆ¶ 5 å°åŒ…ï¼‰
    wctx.strokeStyle = '#000000';
    wctx.lineWidth = 2;
    wctx.beginPath();

    const drawLen = buffer.length;
    const slice = waveCanvas.width / drawLen;
    let x = 0;

    for (let i = 0; i < drawLen; i++) {
      // ä¸­å¿ƒåŒ– + æŒ¯å¹…æ”¾å¤§ï¼ˆé¿å…è¶…å‡ºç•«å¸ƒåšé™å¹…ï¼‰
      const centered = (buffer[i] - 128) / 128; // -1..+1
      const amplified = Math.max(-1, Math.min(1, centered * ampGain));
      const y = waveCanvas.height/2 + amplified * (waveCanvas.height/2 - 2);

      if (i === 0) wctx.moveTo(x, y);
      else wctx.lineTo(x, y);
      x += slice;
    }
    wctx.stroke();

    if (!drawFrozen) { rafId = requestAnimationFrame(drawWaveform); }
  }

  function smoothArray(arr, windowSize=5) {
    const out = new Float32Array(arr.length);
    const half = Math.floor(windowSize/2);
    for (let i=0;i<arr.length;i++){
      let sum = 0, cnt = 0;
      for (let k = -half; k <= half; k++){
        const idx = i + k;
        if (idx >=0 && idx < arr.length) { sum += arr[idx]; cnt++; }
      }
      out[i] = sum / cnt;
    }
    return out;
  }

  function topFrequencies(analyser, sampleRate, topN = 3) {
    const N = analyser.frequencyBinCount; // = FFT_SIZE/2
    const freqData = new Uint8Array(N);
    analyser.getByteFrequencyData(freqData);

    const floatArr = Float32Array.from(freqData, v => v);
    const smoothed = smoothArray(floatArr, 5);

    const minHz = 20;
    const maxHz = Math.min(8000, sampleRate / 2);
    const binHz = sampleRate / FFT_SIZE;

    let totalAmp = 0;
    const candidates = [];
    for (let i = 0; i < N; i++) {
      const hz = i * binHz;
      const amp = Math.max(0, smoothed[i]);
      if (hz >= minHz && hz <= maxHz) { candidates.push({i, hz, amp}); totalAmp += amp; }
    }
    if (totalAmp <= 0) return { list: [], totalAmp: 0 };

    const peaks = [];
    for (let k = 1; k < candidates.length - 1; k++) {
      const a = candidates[k-1].amp, b = candidates[k].amp, c = candidates[k+1].amp;
      if (b > a && b >= c) peaks.push(candidates[k]);
    }
    peaks.sort((p, q) => q.amp - p.amp);

    const merged = [];
    const minSepHz = binHz * 3;
    peaks.forEach(p => { if (!merged.some(m => Math.abs(m.hz - p.hz) < minSepHz)) merged.push(p); });

    const top = merged.slice(0, topN);
    const list = top.map(item => ({ hz: item.hz, ratio: (item.amp / totalAmp) }));
    return { list, totalAmp };
  }

  function updateFreqReadout() {
    if (!analyser || !audioCtx) return;
    const { list } = topFrequencies(analyser, audioCtx.sampleRate, 3);
    if (!list.length) {
      freqReadout.textContent = 'ï¼ˆåµæ¸¬ä¸­â€¦ å°šç„¡é¡¯è‘—ä¸»é »ï¼‰';
      return;
    }
    const lines = list.map((f, idx) =>
      `#${idx+1}  ${f.hz.toFixed(1).padStart(7)} Hz    ä½”æ¯”ï¼š${(f.ratio*100).toFixed(2)}%`
    );
    freqReadout.textContent = lines.join('\n');
  }

  async function startRecording10s() {
    resetAll();
    clearScreen();

    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (err) {
      const msg =
        err.name === 'NotAllowedError' || err.message?.includes('Permission denied') ?
          'ç€è¦½å™¨æ‹’çµ•éº¥å…‹é¢¨æˆæ¬Šï¼š\n1) è‹¥æœ¬é é¢åµŒåœ¨ Google Sites å…§ï¼Œè«‹ã€Œåœ¨æ–°è¦–çª—é–‹å•Ÿã€ã€‚\n2) ç¶²å€åˆ—é–é ­â†’ç¶²ç«™è¨­å®šâ†’éº¥å…‹é¢¨â†’å…è¨±ã€‚\n3) æª¢æŸ¥ä½œæ¥­ç³»çµ±æ˜¯å¦å…è¨±ç€è¦½å™¨ä½¿ç”¨éº¥å…‹é¢¨ã€‚' :
        err.name === 'NotFoundError' ?
          'æ‰¾ä¸åˆ°éº¥å…‹é¢¨ï¼Œè«‹ç¢ºèªè£ç½®èˆ‡ç³»çµ±è¨­å®šã€‚' :
          'å•Ÿç”¨éº¥å…‹é¢¨æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š' + err.message;
      setStatus(msg);
      return;
    }

    // å»ºç«‹éŸ³è¨Šåœ–ï¼šMic â†’ Lowpass â†’ Analyser
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    mediaSource = audioCtx.createMediaStreamSource(mediaStream);

    lowpass = audioCtx.createBiquadFilter();
    lowpass.type = 'lowpass';
    lowpass.frequency.value = parseFloat(lpCut.value); // åˆå§‹æˆªæ­¢
    lowpass.Q.value = 0.707; // æº«å’Œæ–œç‡

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0.85;

    mediaSource.connect(lowpass);
    lowpass.connect(analyser);

    // é–‹å§‹å³æ™‚ç¹ªåœ–èˆ‡ä¸»é »æ›´æ–°
    drawFrozen = false;
    drawingStarted = true;
    rafId = requestAnimationFrame(drawWaveform);

    updateFreqReadout();
    freqTimer = setInterval(updateFreqReadout, FREQ_UPDATE_MS);

    // MediaRecorderï¼ˆä¸å†åˆ»æ„ 2 ç§’ä¸€åŒ…ï¼Œå–æ¶ˆã€Œ5 å°åŒ…ã€æ¦‚å¿µï¼‰
    if (window.MediaRecorder) {
      mediaRecorder = new MediaRecorder(mediaStream);
      mediaRecorder.ondataavailable = () => {};
      mediaRecorder.start(); // ç„¡ timesliceï¼Œæ•´æ®µæ–¼ stop æ™‚å‡ºè³‡æ–™
    }

    btnPause.disabled = false;
    btnPause.textContent = 'â¸ æš«åœæ³¢å½¢';
    setStatus('éŒ„éŸ³ä¸­â€¦ï¼ˆè‡ªå‹•æ–¼ 10 ç§’çµæŸï¼‰');

    // 10 ç§’å¾Œè‡ªå‹•åœæ­¢ï¼ˆä¸¦ä¿ç•™æœ€å¾Œä¸€å¹€ï¼å‡çµï¼‰
    recordTimer = setTimeout(() => {
      drawFrozen = true;
      if (rafId) cancelAnimationFrame(rafId); rafId = null;
      if (freqTimer) clearInterval(freqTimer); freqTimer = null;

      if (mediaRecorder && mediaRecorder.state !== 'inactive') { try { mediaRecorder.stop(); } catch {} }
      if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
      setStatus('å·²è‡ªå‹•çµæŸéŒ„éŸ³ï¼ˆ10 ç§’ï¼‰ã€‚');
    }, 10000);
  }

  // --- äº‹ä»¶ ---
  btnStart.addEventListener('click', startRecording10s);

  btnPause.addEventListener('click', () => {
    if (!drawingStarted) return;
    drawFrozen = !drawFrozen;
    if (!drawFrozen) {
      btnPause.textContent = 'â¸ æš«åœæ³¢å½¢';
      rafId = requestAnimationFrame(drawWaveform);
      if (!freqTimer) freqTimer = setInterval(updateFreqReadout, FREQ_UPDATE_MS);
      setStatus('æŒçºŒæ›´æ–°ä¸­â€¦');
    } else {
      btnPause.textContent = 'â–¶ï¸ ç¹¼çºŒæ³¢å½¢';
      if (rafId) cancelAnimationFrame(rafId); rafId = null;
      if (freqTimer) clearInterval(freqTimer); freqTimer = null;
      setStatus('å·²å‡çµæ³¢å½¢ã€‚');
    }
  });

  btnClear.addEventListener('click', () => {
    resetAll();
    clearScreen();
    setStatus('å·²æ¸…é™¤ç•«é¢ã€‚');
    freqReadout.textContent = '';
  });

  gainSlider.addEventListener('input', () => {
    ampGain = parseFloat(gainSlider.value);
    gainVal.textContent = ampGain.toFixed(1) + 'Ã—';
  });

  lpCut.addEventListener('input', () => {
    lpVal.textContent = lpCut.value + ' Hz';
    if (lowpass) lowpass.frequency.value = parseFloat(lpCut.value);
  });
})();
</script>
</body>
</html>
