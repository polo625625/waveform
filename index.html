<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>10 秒錄音＋即時波形與主頻分析（低通濾波版）</title>
<style>
  :root { --gap: 10px; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto; padding: 16px; }
  h2 { margin: 0 0 12px 0; }
  .toolbar { display: flex; flex-wrap: wrap; gap: var(--gap); margin-bottom: 12px; align-items: center; }
  button { padding: 10px 14px; border: 1px solid #ccc; border-radius: 10px; cursor: pointer; background: #fafafa; }
  button:disabled { opacity: .6; cursor: not-allowed; }
  .controls { display: flex; flex-wrap: wrap; gap: 14px; align-items: center; }
  .control { display: flex; align-items: center; gap: 8px; }
  #status { margin-left: 6px; font-size: 14px; color: #555; }
  .canvases { display: grid; gap: var(--gap); }
  canvas { width: 100%; height: 200px; border: 1px solid #ddd; border-radius: 8px; background: #fff; }
  .panel { display: grid; gap: 6px; }
  .freqs { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre; padding: 10px; border: 1px solid #eee; border-radius: 8px; background: #fcfcfc; }
  .note { font-size: 12px; color:#666; margin-top: 8px; }
  label { user-select: none; }
</style>
</head>
<body>
  <h2>聲音錄製與主頻分析</h2>

  <div class="toolbar">
    <button id="btnStart">🎤 錄音 10 秒</button>
    <button id="btnPause" disabled>⏸ 暫停波形</button>
    <button id="btnClear">🧹 清除</button>
    <span id="status"></span>
  </div>

  <div class="controls">
    <div class="control">
      <label for="gain">振幅放大：</label>
      <input id="gain" type="range" min="1" max="6" step="0.5" value="2">
      <span id="gainVal">2.0×</span>
    </div>
    <div class="control" title="截止頻越低，越能壓掉高頻雜訊（建議 1000–3000 Hz）">
      <label for="lpCut">低通截止頻：</label>
      <input id="lpCut" type="range" min="300" max="8000" step="100" value="2000">
      <span id="lpVal">2000 Hz</span>
    </div>
  </div>

  <div class="canvases" style="margin-top:10px;">
    <div class="panel">
      <label>即時波形（Time Domain）</label>
      <canvas id="waveCanvas" width="900" height="220"></canvas>
    </div>
  </div>

  <div class="panel">
    <label>前三大主頻（即時，已套用低通）</label>
    <div id="freqReadout" class="freqs">尚未開始</div>
  </div>
  <div class="note">提示：請在 HTTPS 的頂層頁面開啟（Google Sites 請用「按鈕→新視窗開啟」）。首次使用會跳出麥克風授權。</div>

<script>
(()=> {
  // --- UI 參考 ---
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnClear = document.getElementById('btnClear');
  const statusEl = document.getElementById('status');
  const waveCanvas = document.getElementById('waveCanvas');
  const wctx = waveCanvas.getContext('2d');
  const freqReadout = document.getElementById('freqReadout');
  const gainSlider = document.getElementById('gain');
  const gainVal = document.getElementById('gainVal');
  const lpCut = document.getElementById('lpCut');
  const lpVal = document.getElementById('lpVal');

  // --- 狀態 ---
  let audioCtx = null;
  let analyser = null;
  let mediaStream = null;
  let mediaSource = null;
  let lowpass = null;        // 低通濾波器
  let rafId = null;
  let drawFrozen = false;
  let drawingStarted = false;
  let freqTimer = null;
  let mediaRecorder = null;
  let recordTimer = null;
  let ampGain = parseFloat(gainSlider.value);

  // FFT/分析設定
  const FFT_SIZE = 4096;
  const FREQ_UPDATE_MS = 150;
  const DRAW_BG = '#ffffff';

  function setStatus(msg) { statusEl.textContent = msg || ''; }

  function resetAll() {
    if (rafId) cancelAnimationFrame(rafId); rafId = null;
    if (freqTimer) clearInterval(freqTimer); freqTimer = null;
    if (recordTimer) clearTimeout(recordTimer); recordTimer = null;

    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      try { mediaRecorder.stop(); } catch {}
    }
    mediaRecorder = null;

    if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
    if (audioCtx) { try { audioCtx.close(); } catch {} audioCtx = null; }

    analyser = null;
    mediaSource = null;
    lowpass = null;
    drawingStarted = false;
    drawFrozen = false;

    btnPause.textContent = '⏸ 暫停波形';
    btnPause.disabled = true;
    setStatus('');
  }

  function clearScreen() {
    wctx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
    freqReadout.textContent = '';
  }

  function drawWaveform() {
    if (!analyser) return;

    const buffer = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(buffer);

    // 背景與中心線
    wctx.fillStyle = DRAW_BG;
    wctx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);
    wctx.strokeStyle = '#e6e6e6';
    wctx.lineWidth = 1;
    wctx.beginPath();
    wctx.moveTo(0, waveCanvas.height/2);
    wctx.lineTo(waveCanvas.width, waveCanvas.height/2);
    wctx.stroke();

    // 畫整段（不再限制 5 封包）
    wctx.strokeStyle = '#000000';
    wctx.lineWidth = 2;
    wctx.beginPath();

    const drawLen = buffer.length;
    const slice = waveCanvas.width / drawLen;
    let x = 0;

    for (let i = 0; i < drawLen; i++) {
      // 中心化 + 振幅放大（避免超出畫布做限幅）
      const centered = (buffer[i] - 128) / 128; // -1..+1
      const amplified = Math.max(-1, Math.min(1, centered * ampGain));
      const y = waveCanvas.height/2 + amplified * (waveCanvas.height/2 - 2);

      if (i === 0) wctx.moveTo(x, y);
      else wctx.lineTo(x, y);
      x += slice;
    }
    wctx.stroke();

    if (!drawFrozen) { rafId = requestAnimationFrame(drawWaveform); }
  }

  function smoothArray(arr, windowSize=5) {
    const out = new Float32Array(arr.length);
    const half = Math.floor(windowSize/2);
    for (let i=0;i<arr.length;i++){
      let sum = 0, cnt = 0;
      for (let k = -half; k <= half; k++){
        const idx = i + k;
        if (idx >=0 && idx < arr.length) { sum += arr[idx]; cnt++; }
      }
      out[i] = sum / cnt;
    }
    return out;
  }

  function topFrequencies(analyser, sampleRate, topN = 3) {
    const N = analyser.frequencyBinCount; // = FFT_SIZE/2
    const freqData = new Uint8Array(N);
    analyser.getByteFrequencyData(freqData);

    const floatArr = Float32Array.from(freqData, v => v);
    const smoothed = smoothArray(floatArr, 5);

    const minHz = 20;
    const maxHz = Math.min(8000, sampleRate / 2);
    const binHz = sampleRate / FFT_SIZE;

    let totalAmp = 0;
    const candidates = [];
    for (let i = 0; i < N; i++) {
      const hz = i * binHz;
      const amp = Math.max(0, smoothed[i]);
      if (hz >= minHz && hz <= maxHz) { candidates.push({i, hz, amp}); totalAmp += amp; }
    }
    if (totalAmp <= 0) return { list: [], totalAmp: 0 };

    const peaks = [];
    for (let k = 1; k < candidates.length - 1; k++) {
      const a = candidates[k-1].amp, b = candidates[k].amp, c = candidates[k+1].amp;
      if (b > a && b >= c) peaks.push(candidates[k]);
    }
    peaks.sort((p, q) => q.amp - p.amp);

    const merged = [];
    const minSepHz = binHz * 3;
    peaks.forEach(p => { if (!merged.some(m => Math.abs(m.hz - p.hz) < minSepHz)) merged.push(p); });

    const top = merged.slice(0, topN);
    const list = top.map(item => ({ hz: item.hz, ratio: (item.amp / totalAmp) }));
    return { list, totalAmp };
  }

  function updateFreqReadout() {
    if (!analyser || !audioCtx) return;
    const { list } = topFrequencies(analyser, audioCtx.sampleRate, 3);
    if (!list.length) {
      freqReadout.textContent = '（偵測中… 尚無顯著主頻）';
      return;
    }
    const lines = list.map((f, idx) =>
      `#${idx+1}  ${f.hz.toFixed(1).padStart(7)} Hz    佔比：${(f.ratio*100).toFixed(2)}%`
    );
    freqReadout.textContent = lines.join('\n');
  }

  async function startRecording10s() {
    resetAll();
    clearScreen();

    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (err) {
      const msg =
        err.name === 'NotAllowedError' || err.message?.includes('Permission denied') ?
          '瀏覽器拒絕麥克風授權：\n1) 若本頁面嵌在 Google Sites 內，請「在新視窗開啟」。\n2) 網址列鎖頭→網站設定→麥克風→允許。\n3) 檢查作業系統是否允許瀏覽器使用麥克風。' :
        err.name === 'NotFoundError' ?
          '找不到麥克風，請確認裝置與系統設定。' :
          '啟用麥克風時發生錯誤：' + err.message;
      setStatus(msg);
      return;
    }

    // 建立音訊圖：Mic → Lowpass → Analyser
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    mediaSource = audioCtx.createMediaStreamSource(mediaStream);

    lowpass = audioCtx.createBiquadFilter();
    lowpass.type = 'lowpass';
    lowpass.frequency.value = parseFloat(lpCut.value); // 初始截止
    lowpass.Q.value = 0.707; // 溫和斜率

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0.85;

    mediaSource.connect(lowpass);
    lowpass.connect(analyser);

    // 開始即時繪圖與主頻更新
    drawFrozen = false;
    drawingStarted = true;
    rafId = requestAnimationFrame(drawWaveform);

    updateFreqReadout();
    freqTimer = setInterval(updateFreqReadout, FREQ_UPDATE_MS);

    // MediaRecorder（不再刻意 2 秒一包，取消「5 封包」概念）
    if (window.MediaRecorder) {
      mediaRecorder = new MediaRecorder(mediaStream);
      mediaRecorder.ondataavailable = () => {};
      mediaRecorder.start(); // 無 timeslice，整段於 stop 時出資料
    }

    btnPause.disabled = false;
    btnPause.textContent = '⏸ 暫停波形';
    setStatus('錄音中…（自動於 10 秒結束）');

    // 10 秒後自動停止（並保留最後一幀＝凍結）
    recordTimer = setTimeout(() => {
      drawFrozen = true;
      if (rafId) cancelAnimationFrame(rafId); rafId = null;
      if (freqTimer) clearInterval(freqTimer); freqTimer = null;

      if (mediaRecorder && mediaRecorder.state !== 'inactive') { try { mediaRecorder.stop(); } catch {} }
      if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }
      setStatus('已自動結束錄音（10 秒）。');
    }, 10000);
  }

  // --- 事件 ---
  btnStart.addEventListener('click', startRecording10s);

  btnPause.addEventListener('click', () => {
    if (!drawingStarted) return;
    drawFrozen = !drawFrozen;
    if (!drawFrozen) {
      btnPause.textContent = '⏸ 暫停波形';
      rafId = requestAnimationFrame(drawWaveform);
      if (!freqTimer) freqTimer = setInterval(updateFreqReadout, FREQ_UPDATE_MS);
      setStatus('持續更新中…');
    } else {
      btnPause.textContent = '▶️ 繼續波形';
      if (rafId) cancelAnimationFrame(rafId); rafId = null;
      if (freqTimer) clearInterval(freqTimer); freqTimer = null;
      setStatus('已凍結波形。');
    }
  });

  btnClear.addEventListener('click', () => {
    resetAll();
    clearScreen();
    setStatus('已清除畫面。');
    freqReadout.textContent = '';
  });

  gainSlider.addEventListener('input', () => {
    ampGain = parseFloat(gainSlider.value);
    gainVal.textContent = ampGain.toFixed(1) + '×';
  });

  lpCut.addEventListener('input', () => {
    lpVal.textContent = lpCut.value + ' Hz';
    if (lowpass) lowpass.frequency.value = parseFloat(lpCut.value);
  });
})();
</script>
</body>
</html>
